import cv2
import numpy as np

# Load the binary image (0 and 255 values only)
image = cv2.imread('your_binary_image.jpg', cv2.IMREAD_GRAYSCALE)

# Ensure the image is binary
_, binary = cv2.threshold(image, 127, 255, cv2.THRESH_BINARY)

# Divide the image into left and right parts
height, width = binary.shape
left_half = binary[:, :width // 2]
right_half = binary[:, width // 2:]

# Function to find and keep the most significant left or right patch
def keep_significant_patch(part, keep_left=True):
    # Find all connected components
    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(part, connectivity=8)

    # Initialize the mask for the significant patch
    significant_mask = np.zeros_like(part)

    # Sort components based on the x-coordinate of the bounding box
    if keep_left:
        # Sort by the leftmost x-coordinate (smallest to largest)
        sorted_indices = np.argsort(stats[:, cv2.CC_STAT_LEFT])
    else:
        # Sort by the rightmost x-coordinate (largest to smallest)
        sorted_indices = np.argsort(stats[:, cv2.CC_STAT_LEFT] + stats[:, cv2.CC_STAT_WIDTH])[::-1]

    # Iterate through the sorted components
    for i in sorted_indices:
        if i == 0:  # Skip the background
            continue

        # Get bounding box of the component
        x, y, w, h, area = stats[i]

        # Check if the component is roughly vertically aligned (adjust tolerance as needed)
        if w < part.shape[1] * 0.3:  # Example condition: width should be less than 30% of the part width
            # Add this component to the mask
            significant_mask[labels == i] = 255

            # Remove all pixels to the right (if left part) or left (if right part)
            if keep_left:
                part[:, x + w:] = 0  # Remove pixels to the right
            else:
                part[:, :x] = 0  # Remove pixels to the left

            break  # Keep only the most significant patch

    return significant_mask

# Process the left half to keep only the leftmost patch or line
left_significant = keep_significant_patch(left_half, keep_left=True)

# Process the right half to keep only the rightmost patch or line
right_significant = keep_significant_patch(right_half, keep_left=False)

# Combine the two parts
result = np.zeros_like(binary)
result[:, :width // 2] = left_significant
result[:, width // 2:] = right_significant

# Display the final result
cv2.imshow('Result', result)
cv2.waitKey(0)
cv2.destroyAllWindows()
